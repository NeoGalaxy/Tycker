var Tycker=function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";const n=r(1),{parseName:i,parseType:o,parseStr:s,Type:c,TypeEditor:a}=r(2);const h=function(e,t,r){return void 0===e&&void 0===t&&void 0===r?h.clone():void 0===t&&void 0===r?h.get(e):h.check(e,t,r)};let l={typeMap:{builtIn:new Map,inherited:new Map,defined:new Map,override:"redefine",get:function(e,t){let r=this.defined.get(e)||this.inherited.get(e)||this.builtIn.get(e);return t||r&&(r=new c(r)),r},isValid:function(e){if(e instanceof c||e instanceof a)return!0;switch(typeof e){case"string":s(e,null,e=>this.get(e));return!0;case"object":for(let t in e)if(!this.isValid(t))return!1;return!0;case"function":return!0;default:return!1}},set:function(e,t,r){if(r||"all"==this.override)return this.defined.set(e,t);if("inherited"==this.override&&this.inherited.has(e))return this.defined.set(e,t);if("defined"==this.override&&this.defined.has(e))return this.defined.set(e,t);if(this.builtIn.has(e))throw new Error("Type name used by a built-in type.");if(this.inherited.has(e))throw new Error("Type name used by an inherited type.");if(this.defined.has(e))throw new Error("Type name used by a defined type.");return this.defined.set(e,t)},copy:function(e="inherited"){if(!["none","same","inherited","defined","all"].includes(e))throw new Error("Invalid copying method. 'canOverride' (first arg) should be 'none', 'same', 'inherited' or 'all'.");return{builtIn:this.builtIn,inherited:"same"==e?new Map(this.inherited):new Map([...this.inherited,...this.defined]),defined:"same"==e?new Map(this.defined):new Map,get:this.get,override:"same"==e?this.override:e,isValid:this.isValid,set:this.set,addtype:function(e,t){this.nameToType.set(e,t),this.typeToName.set(t,e)},copy:this.copy,checkCopy:this.checkCopy}},checkCopy:function(e,t){null==t&&(t=new Array(e.length).fill("unknown"));let r=this.copy(),n=this;return r.get=function(r,i){return r=t[e.indexOf(r)]||r,n.get.call(this,r)},r.find=function(r){return r=t[e.indexOf(r)]||r,n.find.call(this,r)},r.type=function(r){return r=t[e.indexOf(r)]||r,n.type.call(this,r)},r}},get:function(e){let t=this.typeMap.get(e,!0)||o(e,this);return this.check(t,"type",new Error("Impossible to find type "+e)),t.editor(this)},isValid:function(e){return this.typeMap.isValid(e)},def:function(e){var{name:t,force:r,baseType:n,supers:s,checker:c,casts:a}=e;null==a&&(a=[]),null==n&&(n=e.type||"any"),null==s&&(s=[n]);let{typeName:h,subtypes:l}=i(t),u=o(n,this.checkClone(l));s.map(e=>o(e,this.checkClone(l)));u.subtypes=l;let f=u.editor(this);return c&&(f=f.setChecker(c)),a.forEach(e=>{switch(typeof e){case"function":f.addCast(e);break;case"object":f.addCast(e.type,e.function);break;default:throw new TypeError("The casts are not of valid type.")}}),"string"==typeof t&&""!=t&&this.typeMap.set(h,u,r),f},func:function(e="array",t,r="any"){const n=o(e,this),i=o(r,this),s=this;return function(...e){s.check(e,n,new Error("Le type des arguments est invalide."));const r=t.call(this,...e);s.check(r,i,new Error("Le type de retour est invalide."))}},match:function(e,t,r){for(let r of t)if(this.check(e,r.type,!1,1==r.cast))return r.exe(e);if(r instanceof Error)throw r;return r},check:function(e,t,r=!1,n=!1){let i=o(t,this);if(void 0===i)throw new Error("Unable to find type or create anonymous type from above object");if(null==i)throw new Error("Should not occur. Please contact me.");if(n){let t=i.cast(e,this);void 0!==t&&(e=t)}if(i.check.call(i.editor(this),e,this))return!0;if(r instanceof Error)throw r;return r},cast:function(e,t,r){return o(t,this).cast(e,this,r)},addCast:function(e,t,r="any"){this.typeMap.get(e).addCast(t,e)},clone:function(e="same"){if(!["none","same","inherited","all"].includes(e))throw new Error("Invalid cloning method. 'canOverride' (first arg) should be 'none', 'same', 'inherited' or 'all'.");let t=function(e,r,n){return void 0===e&&void 0===r&&void 0===n?t.clone():void 0===r&&void 0===n?t.get(e):t.check(e,r,n)};return Object.keys(this).forEach(e=>{"function"==typeof this[e]&&(t[e]=this[e])}),t.typeMap=this.typeMap.copy(e),t},checkClone:function(e,t){null==t&&(t=new Array(e.length).fill("unknown"));for(var r=t.length;r<e.length;r++)t.push("any");let n=function(e,t,r){if(void 0===e&&void 0===t&&void 0===r)throw new Error("A checkClone can't be cloned");return void 0===t&&void 0===r?n.get(e):n.check(e,t,r)};return n.find=this.find,n.isValid=this.isValid,n.check=this.check,n.checkClone=this.checkClone,n.typeMap=this.typeMap.checkCopy(e,t),n}};for(let e in n)l.typeMap.builtIn.set(e,new c(n[e]));for(let e in l)h[e]=l[e];e.exports=h},function(e,t){const r={any:{check:()=>!0},void:{check:()=>!1},type:{check:(e,t)=>t.isValid(e)},unknown:{check:()=>{throw new Error("This type is unknown")}},int:{check:e=>Number.isInteger(e)},array:{check:e=>Array.isArray(e)},undefined:"undefined",number:"number",boolean:"boolean",string:"string",bigint:"bigint",symbol:"symbol",null:{check:e=>null===e},object:"object",function:"function",Object:Object,Function:Function,Boolean:Boolean,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Number:Number,Date:Date,String:String,RegExp:RegExp,Array:Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet};e.exports=r},function(e,t){class r{constructor(e,t){if("function"!=typeof t)throw new Error("Type editor should not be created without a valid Tycker instance.");this.__type__=e,this.__tycker__=t}setChecker(e,t=!1){let r=this.__type__;if("function"!=typeof e)throw new TypeError("Checker should be a funtion.");if(t)r.check=e;else{let t=r.check;r.check=function(...r){return t.call(this,...r)&&e.call(this,...r)}}return this}check(e,t=!1,r=!1){return this.__tycker__.check(e,this.__type__,t,r)}addCast(...e){return this.__type__.addCast(this.__tycker__,...e),this}cast(e,t){return this.__type__.cast(e,this.__tycker__,t)}}class n{constructor(e){switch(this.subtypes=[],this.casters=[],typeof e){case"string":this.check=t=>typeof t==e;break;case"function":this.check=t=>t instanceof e;break;case"object":e.hasOwnProperty("subtypes")&&(this.subtypes=e.subtypes),e.hasOwnProperty("check")&&(this.check=e.check),e.hasOwnProperty("casters")&&(this.casters=e.casters);break;default:throw new TypeError("Can't create type from given argument.")}}editor(e){return new r(this,e)}addCast(e,t,r){let n=r?t:"any",i=r||t;return e(n,"type",new TypeError("When adding cast: the specified type is invalid.")),e(i,"function",new TypeError("When adding cast: the cast function should be a function.")),this.casters.push({type:n,func:i}),this}cast(e,t,r){let n=this.editor(t);if(this.check.call(n,e,t))return e;for(let r of this.casters){if(!t(e,r.type))continue;let i=r.func.call(n,e,t);if(this.check.call(n,i,t))return i}if(0==this.casters.length&&console.log(new Error("Casting warning : no casting function in type")),r instanceof Error)throw r;return r}}function i(e,t,r){let i={inPar:!1,last:"",type:void 0,enum:void 0},o=[],s=e=>{e.enum.push(e.type),e.type=void 0},c=function(e){s(e);let r=e.enum;e.enum=void 0,e.type=new n({check:(...e)=>r.some(t=>t.check(...e))}),t&&e.type.addCast(t,(e,t,...n)=>{for(type of r){let r=type.cast(e,t,void 0);if(null!=r)return r}})};for(let a of function(e){let t=e.match(/ *([a-zA-Z]+|\(|\)|<([a-zA-Z]+( *, *[a-zA-Z]+)*)?>|\[(\d*(:(\d*)?)?)?\]|\|) */g);if(t.join("")!=e)throw new Error("The string contains invalid characters.");return t.map(e=>e.trim())}(e))switch(a[0]){case"(":if(void 0!==i.type)throw new Error("Two types should not follow each other");o.push(i),i={inPar:!0,last:"",type:void 0,enum:void 0};break;case")":if(!i.inPar)throw new Error("Unmatched closing parenthesis");if(void 0===i.type)throw new Error("Empty parenthesis");i.enum&&c(i);let e=i.type;i=o.pop(),i.type=e,i.last="()";break;case"<":let h=a.slice(1,-1).split(",").map(e=>e.trim());if(""==h[0]&&1==h.length&&(h=[]),""!=i.last)throw new Error("unexpected",a);let l=i.type,u=l.check;i.type.check=function(e,t,...r){return u.call(this,e,t.checkClone(l.subtypes,h),...r)},i.last="<>";break;case"|":i.enum||(i.enum=[]),s(i);break;case"[":if(!["","<>","()"].includes(i.last))throw new Error(`last : ${i.last} -- unexpected `+a);indexes=a.slice(1,-1).split(":");let f=i.type,d=new n({check:1==indexes.length?(e,t,...r)=>t(e,"array")&&(""==indexes[0]||e.length==indexes[0])&&e.every(e=>f.check(e,t,...r)):(e,t,...r)=>t(e,"array")&&(""==indexes[0]||e.length>=indexes[0])&&(""==indexes[1]||e.length<=indexes[1])&&e.every(e=>f.check(e,t,...r))});t&&d.addCast(t,"any"+a,(e,t)=>{let r=new Error;try{return e.map((e,n)=>d.cast(e,t,r))}catch(e){if(e==r)return;throw e}}),i.type=d;break;default:if(i.type=r?r(a):t.typeMap.get(a),null==i.type)throw new Error(`The type ${a} does not exist.`)}if(i.inPar)throw new Error("Unmatched opening parenthesis");if(void 0===i.type)throw new Error("There is no type");return i.enum&&c(i),i.type}e.exports={parseName:function(e){if("string"!=typeof e)return{name:"",subtypes:[]};if(!/^[a-zA-Z]+ ?(< ?[a-zA-Z]+( ?, ?[a-zA-Z]+)* ?>)?$/.test(e))throw new SyntaxError(`Invalid type name '${e}'`);let t=e.replace(" ","").split("<");return{typeName:t[0]?t[0]:void 0,subtypes:t[1]?t[1].slice(0,-1).split(","):[]}},parseType:function(e,t){if(e instanceof n)return e;if(e instanceof r)return e.__type__;if(Array.isArray(e))return e.forEach(e=>{if(!t.isValid(e))throw new Error("The type '"+e+"' is not valid.")}),new n({check:function(t,r){return Array.isArray(t)&&t.length==e.length&&e.every((e,n)=>r(t[n],e))}}).addCast(t,`any[${e.length}]`,(t,r)=>{let n=new Error;try{return e.map((e,i)=>r.cast(t[i],e,n))}catch(e){if(e==n)return;throw e}});if("object"==typeof e){for(let r in e){if(!t.isValid(e[r]))throw new Error("An value of the object is not a valid type.");if("?"==r.slice(-1)&&void 0!==e[r.slice(0,-1)])throw new Error("A key is in double (optionnal and non-optionnal).")}t.typeMap.get("object");return new n({check:function(r,n){if("object"!=typeof r)return!1;for(let t in e){if("..."==t)continue;let i=e[t];if(("?"!=t.slice(-1)||(t=t.slice(0,-1),r.hasOwnProperty(t)))&&!n(r[t],i))return!1}let i=e["..."]||"void";if("any"!=i)for(let n in r)if(!e.hasOwnProperty(n)&&!e.hasOwnProperty(n+"?")&&!t(r[n],i))return!1;return!0}}).addCast(t,"object",(t,r)=>{let n={...t};for(let i in e){if("?"==i.slice(-1)&&(i=i.slice(0,-1),!t.hasOwnProperty(i)))continue;let o=r.cast(t[i],e[i],void 0);if(null==o)return;n[i]=o}return n})}if("function"==typeof e)return new n(e);if("string"==typeof e){try{var o=i(e,t)}catch(t){throw new Error("No type matching "+e)}if(null==o)throw new Error("Should not occur - please contact me");return o}throw new TypeError("Invalid type element.")},parseStr:i,TypeEditor:r,Type:n}}]);